---
title: Masked Similarity Computation
author: Kohei Watanabe
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE
)
```

**proxyC** v0.5 introduces masked similarity computation to improve the execution time and memory usage. In the toy example, we compute similarity only between column vectors in `mt1` and `mt2` with the alphabetical names. We can achieve this by creating a pattern matrix `msk` using `mask()` and passing it to `simil()`. 

## Example

```{r}
require(proxyC)
require(Matrix)

mt1 <- rsparsematrix(100, 6, 1.0)
colnames(mt1) <- c("a", "a", "d", "d", "e", "e")
mt2 <- rsparsematrix(100, 5, 1.0)
colnames(mt2) <- c("a", "b", "c", "d", "e")

(msk <- mask(colnames(mt1), colnames(mt2)))
(sim <- simil(mt1, mt2, margin = 2, method = "cosine", mask = msk, drop0 = TRUE))
```

## Execution Times

With large matrices, we can measures the impact of masked similarity computation.

```{r}
require(microbenchmark)
require(ggplot2)

mt1 <- rsparsematrix(1000L, 2600L, 0.1)
colnames(mt1) <- rep(letters, each = 100L)
mt2 <- rsparsematrix(1000L, 26L, 0.1)
colnames(mt2) <- letters
msk <- mask(colnames(mt1), colnames(mt2))
```

### Cosine Similarity

The impact of masking is limited in cosine similarity because **proxyC** employs linear algebra extensively. It computes all the similarity scores but saves values for only unmasked pairs if `method` is either "cosine", "correlation" or "euclidean".


```{r timeCosine, fig.width=7, fig.height=4}
bm <- microbenchmark(
    unmasked = simil(mt1, mt2, margin = 2, method = "cosine", mask = NULL, drop0 = TRUE),
    masked = simil(mt1, mt2, margin = 2, method = "cosine", mask = msk, drop0 = TRUE)
)

autoplot(bm)
```

### Dice Coefficient

Masking has the greatest impact on the execution time in other methods because **proxyC** computes and saves Dice coefficients only for unmasked pairs. We expect to see similar performance improvement in "jaccard", "ejaccard", "fjaccard", "edice", "hamann", "faith" and"simple matching".

```{r timeDice, fig.width=7, fig.height=4}
bm <- microbenchmark(
    unmasked = simil(mt1, mt2, margin = 2, method = "jaccard", mask = NULL, drop0 = TRUE),
    masked = simil(mt1, mt2, margin = 2, method = "jaccard", mask = msk, drop0 = TRUE)
)

autoplot(bm)
```

## Object Sizes

Masking also dramatically reduces the sizes of similarity matrices when `drop0 = TRUE`.

```{r objectSize, fig.width=7, fig.height=4}
sim_um <- simil(mt1, mt2, margin = 2, method = "cosine", mask = NULL, drop0 = TRUE)
sim_mk <- simil(mt1, mt2, margin = 2, method = "cosine", mask = msk, drop0 = TRUE)

print(object.size(sim_um), unit = "KB")
print(object.size(sim_mk), unit = "KB")
```
